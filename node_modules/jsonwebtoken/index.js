function parseExpiry(value) {
  if (!value) return null;
  if (typeof value === "number") return value * 1000;
  const match = String(value).match(/^(\d+)([smhd])?$/);
  if (!match) return null;
  const amount = Number(match[1]);
  const unit = match[2] || "s";
  const multipliers = { s: 1000, m: 60_000, h: 3_600_000, d: 86_400_000 };
  return amount * (multipliers[unit] || 1000);
}

function encode(payload, secret, expiresIn) {
  const expMs = parseExpiry(expiresIn);
  const tokenPayload = { payload, exp: expMs ? Date.now() + expMs : null };
  const body = Buffer.from(JSON.stringify(tokenPayload)).toString("base64url");
  const signature = Buffer.from(secret || "").toString("base64url");
  return `${body}.${signature}`;
}

function decodeToken(token) {
  const [body] = String(token).split(".");
  if (!body) throw new Error("jwt malformed");
  return JSON.parse(Buffer.from(body, "base64url").toString("utf-8"));
}

export function sign(payload, secret, options = {}) {
  return encode(payload, secret, options.expiresIn);
}

export function verify(token, secret) {
  const [bodyPart, signature = ""] = String(token).split(".");
  const expected = Buffer.from(secret || "").toString("base64url");
  if (signature !== expected) {
    throw new Error("invalid signature");
  }
  const decoded = JSON.parse(Buffer.from(bodyPart, "base64url").toString("utf-8"));
  if (decoded.exp && Date.now() > decoded.exp) {
    throw new Error("jwt expired");
  }
  return decoded.payload;
}

export function decode(token) {
  return decodeToken(token);
}

export default { sign, verify, decode };
