import { createServer } from "node:http";
import { URL } from "node:url";

function enhanceResponse(res) {
  if (res.__enhanced) return res;
  res.__enhanced = true;
  res.status = (code) => {
    res.statusCode = code;
    return res;
  };
  res.header = (name, value) => {
    res.setHeader(name, value);
    return res;
  };
  res.json = (data) => {
    if (!res.headersSent) {
      res.setHeader("Content-Type", "application/json");
    }
    res.end(data === undefined ? "null" : JSON.stringify(data));
  };
  res.send = (data) => {
    if (data === undefined) {
      res.end();
      return;
    }
    if (typeof data === "object" && !(data instanceof Buffer)) {
      res.setHeader("Content-Type", "application/json");
      res.end(JSON.stringify(data));
      return;
    }
    res.end(data);
  };
  return res;
}

function pathToRegex(path, isUse = false) {
  if (!path || path === "/") {
    return { regex: isUse ? /^/ : /^\/$/, keys: [] };
  }

  const keys = [];
  const escaped = path
    .split("/")
    .filter(Boolean)
    .map((segment) => {
      if (segment.startsWith(":")) {
        keys.push(segment.slice(1));
        return "([^/]+)";
      }
      return segment.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    })
    .join("/");

  const suffix = isUse ? "(?=$|/)" : "/?$";
  return { regex: new RegExp(`^/${escaped}${suffix}`), keys };
}

function buildLayer(method, path, handler, isUse = false) {
  const { regex, keys } = pathToRegex(path, isUse);
  return { method, path: path || "/", handler, regex, keys, isUse };
}

function addLayer(stack, method, path, handler, isUse = false) {
  const layer = buildLayer(method, path, handler, isUse);
  stack.push(layer);
}

function matchLayer(layer, pathname) {
  const match = pathname.match(layer.regex);
  if (!match) return null;
  const params = {};
  layer.keys.forEach((key, index) => {
    params[key] = match[index + 1];
  });
  return params;
}

function dispatch(stack, req, res) {
  enhanceResponse(res);
  const url = new URL(req.url, `http://${req.headers.host || "localhost"}`);
  req.originalUrl = req.originalUrl || req.url;
  req.path = url.pathname;
  req.query = Object.fromEntries(url.searchParams.entries());
  req.params = req.params || {};

  let idx = 0;
  let error = null;

  const next = (err) => {
    error = err || null;
    run();
  };

  function run() {
    while (idx < stack.length) {
      const layer = stack[idx++];

      const methodMatches =
        layer.method === "USE" ||
        layer.method === "ALL" ||
        (req.method && layer.method === req.method.toUpperCase());
      const wantsErrorHandler = Boolean(error);
      const isErrorHandler = layer.handler.length === 4;

      if (wantsErrorHandler !== isErrorHandler) continue;
      if (!methodMatches && !layer.isUse) continue;

      const params = matchLayer(layer, req.path);
      if (!params) continue;

      req.params = { ...req.params, ...params };

      try {
        if (isErrorHandler) {
          return layer.handler(error, req, res, next);
        }

        if (layer.handler.length >= 3) {
          return layer.handler(req, res, next);
        }

        const result = layer.handler(req, res);
        if (result && typeof result.then === "function") {
          result.then(() => {
            if (!res.writableEnded) next();
          }).catch(next);
          return;
        }

        if (!res.writableEnded) {
          continue;
        }
        return;
      } catch (handlerError) {
        error = handlerError;
        continue;
      }
    }

    if (error) {
      res.status(error.status || error.statusCode || 500);
      const message = error.message || "Internal Server Error";
      if (!res.headersSent) {
        res.setHeader("Content-Type", "application/json");
      }
      res.end(JSON.stringify({ message, code: error.code }));
      return;
    }

    if (!res.writableEnded) {
      res.statusCode = 404;
      res.end(JSON.stringify({ message: "Not Found" }));
    }
  }

  run();
}

function createRouter() {
  const stack = [];
  const router = (req, res, next) => {
    const combinedNext = (err) => {
      if (err) return next(err);
      next();
    };
    dispatch(stack, req, res, combinedNext);
  };

  router._stack = stack;
  router._isRouter = true;
  router.use = (path, ...handlers) => {
    if (typeof path === "function") {
      handlers = [path, ...handlers];
      path = "/";
    }
    handlers.forEach((handler) => addLayer(stack, "USE", path, handler, true));
    return router;
  };

  ["all", "get", "post", "put", "delete", "patch", "options"].forEach((method) => {
    router[method] = (path, ...handlers) => {
      const finalMethod = method.toUpperCase();
      handlers.forEach((handler) => addLayer(stack, finalMethod, path, handler, finalMethod === "USE"));
      return router;
    };
  });

  return router;
}

function flattenRouter(stack, mountPath, router) {
  router._stack.forEach((layer) => {
    const combinedPath = `${mountPath.replace(/\/$/, "")}${layer.path === "/" ? "" : layer.path}` || "/";
    addLayer(stack, layer.method, combinedPath || "/", layer.handler, layer.isUse || layer.method === "USE");
  });
}

function createApp() {
  const stack = [];
  const app = (req, res) => dispatch(stack, req, res);
  app._stack = stack;

  app.use = (path, ...handlers) => {
    if (typeof path === "function" || path?._isRouter) {
      handlers = [path, ...handlers];
      path = "/";
    }
    handlers.forEach((handler) => {
      if (handler?._isRouter) {
        flattenRouter(stack, path || "/", handler);
      } else {
        addLayer(stack, "USE", path || "/", handler, true);
      }
    });
    return app;
  };

  ["all", "get", "post", "put", "delete", "patch", "options"].forEach((method) => {
    app[method] = (path, ...handlers) => {
      const finalMethod = method.toUpperCase();
      handlers.forEach((handler) => addLayer(stack, finalMethod, path, handler));
      return app;
    };
  });

  app.listen = (...args) => createServer(app).listen(...args);

  return app;
}

function jsonParser() {
  return (req, _res, next) => {
    const contentType = req.headers["content-type"] || "";
    if (!contentType.includes("application/json")) {
      return next();
    }
    let body = "";
    req.on("data", (chunk) => {
      body += chunk;
    });
    req.on("end", () => {
      try {
        req.body = body ? JSON.parse(body) : {};
      } catch (_error) {
        req.body = null;
      }
      next();
    });
    req.on("error", (err) => next(err));
  };
}

function urlencodedParser() {
  return (req, _res, next) => {
    if ((req.headers["content-type"] || "").includes("application/json")) {
      return next();
    }
    let body = "";
    req.on("data", (chunk) => {
      body += chunk;
    });
    req.on("end", () => {
      req.body = body;
      next();
    });
    req.on("error", (err) => next(err));
  };
}

const express = () => createApp();

express.Router = createRouter;
express.json = jsonParser;
express.urlencoded = urlencodedParser;

export default express;
